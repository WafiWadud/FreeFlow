<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Generator Repair - Flow Free</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #1a1a1a;
        font-family: "Arial", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        color: #fff;
      }

      .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 10px;
      }

      .header h1 {
        margin: 0 0 10px 0;
        font-size: 28px;
        color: #00ff88;
        text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
      }

      .generator-bar-container {
        width: 400px;
        max-width: 90vw;
        background: #0a0a0a;
        border: 2px solid #00ff88;
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      }

      .generator-label {
        font-size: 14px;
        margin-bottom: 8px;
        color: #00ff88;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .generator-bar {
        width: 100%;
        height: 30px;
        background: #222;
        border-radius: 5px;
        overflow: hidden;
        position: relative;
        border: 1px solid #333;
      }

      .generator-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ff88, #00ccff);
        transition: width 0.5s ease;
        box-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
      }

      .generator-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: bold;
        font-size: 12px;
        color: #fff;
        text-shadow: 1px 1px 2px #000;
      }

      .info-bar {
        display: flex;
        justify-content: space-between;
        width: 400px;
        max-width: 90vw;
        font-size: 16px;
        color: #aaa;
      }

      .grid {
        width: 40rem;
        height: 40rem;
        background: #000;
        overflow: hidden;
        box-sizing: border-box;
        border: 3px solid #00ff88;
        border-radius: 5px;
        box-shadow: 0 0 30px rgba(0, 255, 136, 0.4);
      }

      .grid > div {
        float: left;
        position: relative;
        width: calc(100% / 6);
        height: calc(100% / 6);
        box-sizing: border-box;
        border: 1px solid #444;
        background-image: radial-gradient(
          ellipse at center,
          transparent 0,
          transparent 20.5%,
          #000 21.484374%
        );
        cursor: pointer;
        transition: background-color 0.1s;
      }

      .grid > div[data-completed="true"] {
        background-image: radial-gradient(
          ellipse at center,
          transparent 0,
          transparent 20.5%,
          rgba(0, 0, 0, 0.8) 21.484374%
        );
      }

      .grid > div[data-point="true"] {
        background-image: radial-gradient(
          ellipse at center,
          transparent 0,
          transparent 45%,
          #000 50%
        );
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 18px;
        color: #000;
        text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
      }

      .grid > div[data-point="true"][data-completed="true"] {
        background-image: radial-gradient(
          ellipse at center,
          transparent 0,
          transparent 45%,
          rgba(0, 0, 0, 0.8) 50%
        );
      }

      .grid > div::before,
      .grid > div::after {
        content: "";
        position: absolute;
        display: block;
        background-color: inherit;
      }

      .grid > div[data-t]::before {
        width: 30%;
        height: 50%;
        left: 35%;
        top: -1px;
      }

      .grid > div[data-b]::before {
        width: 30%;
        height: 50%;
        left: 35%;
        bottom: -1px;
      }

      .grid > div[data-l]::before {
        width: 50%;
        height: 30%;
        left: -1px;
        top: 35%;
      }

      .grid > div[data-r]::before {
        width: 50%;
        height: 30%;
        right: -1px;
        top: 35%;
      }

      .grid > div[data-t][data-b]::before {
        width: 30%;
        height: calc(100% + 2px);
        left: 35%;
        top: -1px;
      }

      .grid > div[data-l][data-r]::before {
        width: calc(100% + 2px);
        height: 30%;
        left: -1px;
        top: 35%;
      }

      .grid > div[data-t][data-l]::before {
        width: 30%;
        height: 50%;
        left: 35%;
        top: -1px;
      }

      .grid > div[data-t][data-l]::after {
        width: 50%;
        height: 30%;
        left: -1px;
        top: 35%;
      }

      .grid > div[data-t][data-r]::before {
        width: 30%;
        height: 50%;
        left: 35%;
        top: -1px;
      }

      .grid > div[data-t][data-r]::after {
        width: 50%;
        height: 30%;
        right: -1px;
        top: 35%;
      }

      .grid > div[data-b][data-l]::before {
        width: 30%;
        height: 50%;
        left: 35%;
        bottom: -1px;
      }

      .grid > div[data-b][data-l]::after {
        width: 50%;
        height: 30%;
        left: -1px;
        top: 35%;
      }

      .grid > div[data-b][data-r]::before {
        width: 30%;
        height: 50%;
        left: 35%;
        bottom: -1px;
      }

      .grid > div[data-b][data-r]::after {
        width: 50%;
        height: 30%;
        right: -1px;
        top: 35%;
      }

      .grid > div[data-id="1"] {
        background-color: #fc0d1b;
      }
      .grid > div[data-id="2"] {
        background-color: #0f7f12;
      }
      .grid > div[data-id="3"] {
        background-color: #0b24fb;
      }
      .grid > div[data-id="4"] {
        background-color: #eeec33;
      }
      .grid > div[data-id="5"] {
        background-color: #fd7f23;
      }
      .grid > div[data-id="6"] {
        background-color: #2dfffe;
      }
      .grid > div[data-id="7"] {
        background-color: #fc28fc;
      }
      .grid > div[data-id="8"] {
        background-color: #a32b2e;
      }
      .grid > div[data-id="9"] {
        background-color: #7f0f7e;
      }
      .grid > div[data-id="10"] {
        background-color: #ffffff;
      }
      .grid > div[data-id="11"] {
        background-color: #a6a6a6;
      }
      .grid > div[data-id="12"] {
        background-color: #29fd2f;
      }
      .grid > div[data-id="13"] {
        background-color: #bdb66f;
      }

      .completion-message {
        font-size: 20px;
        color: #00ff88;
        font-weight: bold;
        animation: pulse 1s infinite;
        text-align: center;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      .victory-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .victory-content {
        background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        border: 3px solid #00ff88;
        box-shadow: 0 0 50px rgba(0, 255, 136, 0.6);
      }

      .victory-content h2 {
        font-size: 36px;
        color: #00ff88;
        margin: 0 0 20px 0;
        text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
      }

      .victory-content p {
        font-size: 18px;
        color: #aaa;
        margin-bottom: 30px;
      }

      button {
        background: #00ff88;
        color: #000;
        border: none;
        padding: 12px 30px;
        font-size: 16px;
        font-weight: bold;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      button:hover {
        background: #00ccff;
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="header">
        <h1>âš¡ Generator Repair âš¡</h1>
      </div>

      <div class="generator-bar-container">
        <div class="generator-label">Generator Power</div>
        <div class="generator-bar">
          <div class="generator-fill" id="generatorFill"></div>
          <div class="generator-text" id="generatorText">0%</div>
        </div>
      </div>

      <div class="info-bar">
        <div>Layer: <span id="layerNum">1</span> / 5</div>
        <div>
          Pairs: <span id="pairCount">0</span> / <span id="totalPairs">0</span>
        </div>
      </div>

      <div class="grid"></div>

      <div
        id="completionMsg"
        class="completion-message"
        style="display: none"
      ></div>
    </div>

    <div class="victory-screen" id="victoryScreen">
      <div class="victory-content">
        <h2>ðŸŽ‰ GENERATOR REPAIRED! ðŸŽ‰</h2>
        <p>All five layers completed successfully!</p>
        <button onclick="location.reload()">Play Again</button>
      </div>
    </div>

    <script>
      (function () {
        let currentColor = null;
        let previousPoint = null;
        let currentCell = null;
        let paths = {};
        let isDrawing = false;
        let gridSize = 6;
        let currentLayer = 1;
        let totalLayers = 5;
        let pairsNeeded = 0;
        let pairsCompleted = 0;

        function init() {
          generateRandomLevel();
          updateUI();
        }

        function generateRandomLevel() {
          let success = false;

          // Try with random pairs first
          for (let attempt = 0; attempt < 20 && !success; attempt++) {
            success = tryGenerateLevel();
          }

          // Fallback with fewer pairs
          if (!success) {
            for (let pairs = 8; pairs >= 5 && !success; pairs--) {
              for (let attempt = 0; attempt < 10 && !success; attempt++) {
                success = tryGenerateLevel(pairs);
              }
            }
          }

          // Final fallback - very simple
          if (!success) {
            success = tryGenerateLevel(4);
          }
        }

        function rand(a, b) {
          return (
            (a +
              ((b - a + 1) * crypto.getRandomValues(new Uint32Array(1))[0]) /
                2 ** 32) |
            0
          );
        }

        function tryGenerateLevel(forcePairs = null) {
          let numPairs = forcePairs || rand(6, 10); // 6-10 pairs
          pairsNeeded = numPairs;
          pairsCompleted = 0;

          let grid = document.querySelector(".grid");
          grid.innerHTML = "";
          paths = {};

          // Create solution paths first
          let cells = new Array(36).fill(0);
          let occupied = new Array(36).fill(false);
          let pathCells = [];

          // Generate each path using pathfinding with constraints
          for (let colorId = 1; colorId <= numPairs; colorId++) {
            let bestPath = null;
            let bestStart = -1;
            let bestEnd = -1;
            let bestScore = -Infinity;

            for (let attempt = 0; attempt < 50; attempt++) {
              // Pick random unoccupied positions
              let availablePositions = [];
              for (let i = 0; i < 36; i++) {
                if (!occupied[i]) availablePositions.push(i);
              }

              if (availablePositions.length < 2) break;

              // Pick start
              let startIdx = Math.floor(
                Math.random() * availablePositions.length,
              );
              let startPos = availablePositions[startIdx];

              // Pick end (different from start)
              availablePositions.splice(startIdx, 1);
              let endIdx = Math.floor(
                Math.random() * availablePositions.length,
              );
              let endPos = availablePositions[endIdx];

              // Check distance
              let dist =
                Math.abs((startPos % 6) - (endPos % 6)) +
                Math.abs(Math.floor(startPos / 6) - Math.floor(endPos / 6));

              if (dist < 2) continue;

              // Find a path
              let path = findConstrainedPath(
                startPos,
                endPos,
                occupied,
                colorId,
                numPairs,
              );

              if (path && path.length >= 2) {
                // Score based on length and turns
                let score = path.length;
                let turns = 0;
                for (let i = 2; i < path.length; i++) {
                  let dir1 = getDirectionSimple(path[i - 2], path[i - 1]);
                  let dir2 = getDirectionSimple(path[i - 1], path[i]);
                  if (dir1 !== dir2) turns++;
                }
                score += turns * 2;

                if (score > bestScore) {
                  bestScore = score;
                  bestPath = path;
                  bestStart = startPos;
                  bestEnd = endPos;
                }
              }
            }

            if (!bestPath) {
              return false; // Failed to generate this puzzle
            }

            // Mark all cells in path as occupied
            bestPath.forEach((pos) => {
              occupied[pos] = true;
            });

            // Mark only endpoints in cells array
            cells[bestStart] = colorId;
            cells[bestEnd] = colorId;

            pathCells.push({ color: colorId, path: bestPath });
          }

          // Build grid with only endpoints visible
          cells.forEach((val) => {
            let div = document.createElement("div");
            if (val) {
              div.setAttribute("data-id", val);
              div.setAttribute("data-point", "true");
              div.textContent = val;
            }
            grid.appendChild(div);
          });

          // Attach event listeners
          Array.from(grid.querySelectorAll("div")).forEach((cell, index) => {
            cell.setAttribute("data-i", index);

            if ("ontouchstart" in document) {
              cell.addEventListener("touchstart", startDraw, false);
              cell.addEventListener("touchmove", moveDraw, false);
              cell.addEventListener("touchend", endDraw, false);
            } else {
              cell.addEventListener("mousedown", startDraw, false);
              cell.addEventListener("mousemove", moveDraw, false);
              cell.addEventListener("mouseup", endDraw, false);
            }
          });

          return true;
        }

        function getDirectionSimple(pos1, pos2) {
          let dx = (pos2 % 6) - (pos1 % 6);
          let dy = Math.floor(pos2 / 6) - Math.floor(pos1 / 6);

          if (dx === -1 && dy === 0) return "l";
          if (dx === 1 && dy === 0) return "r";
          if (dx === 0 && dy === -1) return "t";
          if (dx === 0 && dy === 1) return "b";
          return null;
        }

        function findConstrainedPath(
          start,
          end,
          occupied,
          colorId,
          totalPairs,
        ) {
          // A* pathfinding with constraints to make harder puzzles
          let openSet = [
            { pos: start, g: 0, h: heuristic(start, end), parent: null },
          ];
          let closedSet = new Set();
          let cameFrom = new Map();

          while (openSet.length > 0) {
            // Get node with lowest f score
            openSet.sort((a, b) => a.g + a.h - (b.g + b.h));
            let current = openSet.shift();

            if (current.pos === end) {
              // Reconstruct path
              let path = [];
              let node = current.pos;
              while (cameFrom.has(node)) {
                path.unshift(node);
                node = cameFrom.get(node);
              }
              path.unshift(start);
              return path;
            }

            closedSet.add(current.pos);

            // Check neighbors
            let neighbors = getNeighbors(current.pos);

            for (let neighbor of neighbors) {
              if (closedSet.has(neighbor)) continue;
              if (occupied[neighbor] && neighbor !== end) continue;

              let tentativeG = current.g + 1;
              let existing = openSet.find((n) => n.pos === neighbor);

              if (!existing) {
                openSet.push({
                  pos: neighbor,
                  g: tentativeG,
                  h: heuristic(neighbor, end),
                  parent: current.pos,
                });
                cameFrom.set(neighbor, current.pos);
              } else if (tentativeG < existing.g) {
                existing.g = tentativeG;
                cameFrom.set(neighbor, current.pos);
              }
            }
          }

          return null; // No path found
        }

        function heuristic(pos1, pos2) {
          // Manhattan distance
          let x1 = pos1 % 6,
            y1 = Math.floor(pos1 / 6);
          let x2 = pos2 % 6,
            y2 = Math.floor(pos2 / 6);
          return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        function getNeighbors(pos) {
          let neighbors = [];
          let x = pos % 6,
            y = Math.floor(pos / 6);

          if (x > 0) neighbors.push(pos - 1); // left
          if (x < 5) neighbors.push(pos + 1); // right
          if (y > 0) neighbors.push(pos - 6); // up
          if (y < 5) neighbors.push(pos + 6); // down

          return neighbors;
        }

        function updateUI() {
          document.getElementById("layerNum").textContent = currentLayer;
          document.getElementById("totalPairs").textContent = pairsNeeded;
          document.getElementById("pairCount").textContent = pairsCompleted;

          let progress =
            ((currentLayer - 1) / totalLayers) * 100 +
            (pairsCompleted / pairsNeeded) * (100 / totalLayers);
          document.getElementById("generatorFill").style.width = progress + "%";
          document.getElementById("generatorText").textContent =
            Math.round(progress) + "%";
        }

        function checkCompletion() {
          let allPairsComplete = true;
          for (let i = 1; i <= pairsNeeded; i++) {
            if (!paths[i] || !isPathComplete(i)) {
              allPairsComplete = false;
              break;
            }
          }

          if (allPairsComplete) {
            let msg = document.getElementById("completionMsg");
            msg.style.display = "block";

            if (currentLayer < totalLayers) {
              msg.textContent = `Layer ${currentLayer} Complete!`;
              setTimeout(() => {
                msg.style.display = "none";
                currentLayer++;
                generateRandomLevel();
                updateUI();
              }, 1000);
            } else {
              msg.textContent = "All Layers Complete!";
              document.getElementById("victoryScreen").style.display = "flex";
            }
          }
        }

        function isPathComplete(colorId) {
          if (!paths[colorId]) return false;

          let grid = document.querySelector(".grid");
          let endpoints = grid.querySelectorAll(
            `div[data-point="true"][data-id="${colorId}"]`,
          );

          if (endpoints.length !== 2) return false;

          let completed = 0;
          endpoints.forEach((ep) => {
            if (ep.getAttribute("data-completed") === "true") {
              completed++;
            }
          });

          return completed === 2;
        }

        function getDirection(i1, i2) {
          if (typeof i1 === "object") {
            i1 = parseInt(i1.getAttribute("data-i"));
          }
          if (typeof i2 === "object") {
            i2 = parseInt(i2.getAttribute("data-i"));
          }

          let dx = (i2 % 6) - (i1 % 6);
          let dy = Math.floor(i2 / 6) - Math.floor(i1 / 6);

          if (dx === 1 && dy === 0) return "r";
          if (dx === -1 && dy === 0) return "l";
          if (dx === 0 && dy === 1) return "b";
          if (dx === 0 && dy === -1) return "t";
          return false;
        }

        function trimPath(path, keep) {
          if (!path || !path.length) return [];

          let id = path[0].getAttribute("data-id");
          let grid = document.querySelector(".grid");

          // Check if path was previously completed
          let wasCompleted = isPathComplete(id);

          grid.querySelectorAll(`div[data-id="${id}"]`).forEach((cell) => {
            cell.removeAttribute("data-completed");
          });

          keep = keep || 1;

          while (path.length > keep) {
            let tail = path.pop();
            let before = path[path.length - 1];

            if (!tail || !before) break;

            let tailIdx = parseInt(tail.getAttribute("data-i"));
            let beforeIdx = parseInt(before.getAttribute("data-i"));

            // Calculate which direction the tail is from before
            let dx = (tailIdx % 6) - (beforeIdx % 6);
            let dy = Math.floor(tailIdx / 6) - Math.floor(beforeIdx / 6);

            let tailDir = null;
            let beforeDir = null;

            if (dx === 1) {
              tailDir = "r";
              beforeDir = "l";
            } else if (dx === -1) {
              tailDir = "l";
              beforeDir = "r";
            } else if (dy === 1) {
              tailDir = "b";
              beforeDir = "t";
            } else if (dy === -1) {
              tailDir = "t";
              beforeDir = "b";
            }

            if (tail.getAttribute("data-point") !== "true") {
              tail.removeAttribute("data-id");
              tail.textContent = "";
            }

            if (tailDir) tail.removeAttribute(`data-${beforeDir}`);
            if (beforeDir) before.removeAttribute(`data-${tailDir}`);
          }

          if (path.length === 1) path.pop();

          // If path was completed and now isn't, decrement counter
          if (wasCompleted && pairsCompleted > 0) {
            pairsCompleted--;
            updateUI();
          }

          return path;
        }

        function startDraw(e) {
          let id = parseInt(this.getAttribute("data-id"));
          if (!id) return;

          if (e.type.startsWith("mouse") && e.which !== 1) return;

          previousPoint = currentColor;
          currentColor = id;

          if (currentCell !== e.target) {
            previousPoint = currentCell;
            currentCell = e.target;

            if (currentCell.getAttribute("data-point") === "true") {
              paths[id] = paths[id] ? trimPath(paths[id]) : [];
            } else {
              if (paths[id]) {
                let idx = paths[id].indexOf(e.target);
                if (idx > -1) {
                  paths[id] = trimPath(paths[id], idx + 1);
                  previousPoint = paths[id][paths[id].length - 1];
                }
              } else {
                paths[id] = [];
              }
            }
            paths[id].push(currentCell);
          }

          isDrawing = true;
          e.preventDefault();
        }

        function moveDraw(e) {
          if (!isDrawing) return;

          let target = e.target;

          if (e.type.startsWith("touch")) {
            let touch = e.touches[0];
            target = document.elementFromPoint(touch.clientX, touch.clientY);
          }

          if (!target || !currentCell || target === currentCell) {
            e.preventDefault();
            return;
          }

          let currentIdx = parseInt(currentCell.getAttribute("data-i"));
          let targetIdx = parseInt(target.getAttribute("data-i"));

          if (isNaN(currentIdx) || isNaN(targetIdx)) {
            e.preventDefault();
            return;
          }

          // Calculate direction from current to target
          let dx = (targetIdx % 6) - (currentIdx % 6);
          let dy = Math.floor(targetIdx / 6) - Math.floor(currentIdx / 6);

          // Only allow adjacent cells
          if (Math.abs(dx) + Math.abs(dy) !== 1) {
            e.preventDefault();
            return;
          }

          let dirFromCurrent = null;
          let dirFromTarget = null;

          if (dx === 1) {
            dirFromCurrent = "r";
            dirFromTarget = "l";
          } else if (dx === -1) {
            dirFromCurrent = "l";
            dirFromTarget = "r";
          } else if (dy === 1) {
            dirFromCurrent = "b";
            dirFromTarget = "t";
          } else if (dy === -1) {
            dirFromCurrent = "t";
            dirFromTarget = "b";
          }

          if (!dirFromCurrent) {
            e.preventDefault();
            return;
          }

          let id = parseInt(target.getAttribute("data-id"));
          let isPoint = target.getAttribute("data-point") === "true";

          if (id == currentColor) {
            // Ensure path exists
            if (!paths[currentColor]) {
              paths[currentColor] = [];
            }

            let idx = paths[currentColor].indexOf(target);

            if (idx > -1) {
              paths[currentColor] = trimPath(paths[currentColor], idx + 1);
              if (paths[currentColor].length > 0) {
                currentCell =
                  paths[currentColor][paths[currentColor].length - 1];
                previousPoint =
                  paths[currentColor][paths[currentColor].length - 2];
              }
            } else if (isPoint) {
              previousPoint = currentCell;
              currentCell = target;

              paths[currentColor].push(target);
              paths[currentColor].forEach((c) =>
                c.setAttribute("data-completed", "true"),
              );

              target.setAttribute("data-id", currentColor);
              target.setAttribute(`data-${dirFromTarget}`, "");
              previousPoint.setAttribute(`data-${dirFromCurrent}`, "");

              pairsCompleted++;
              updateUI();
              checkCompletion();
            }
          } else if (!id) {
            if (
              currentCell.getAttribute("data-point") &&
              paths[currentColor] &&
              paths[currentColor].length > 1
            )
              return;

            previousPoint = currentCell;
            currentCell = target;

            target.setAttribute("data-id", currentColor);
            target.setAttribute(`data-${dirFromTarget}`, "");
            previousPoint.setAttribute(`data-${dirFromCurrent}`, "");

            if (!paths[currentColor]) {
              paths[currentColor] = [];
            }
            paths[currentColor].push(target);
          }

          e.preventDefault();
        }

        function endDraw(e) {
          if (isDrawing) {
            isDrawing = false;
            e.preventDefault();
          }
        }

        init();
      })();
    </script>
  </body>
</html>
